<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>source/skylinkcc.js - skylinkcc</title>
    <!-- font and icon -->
    <link rel="shortcut icon" type="image/ico" href="../assets/favicon.ico">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700|Source+Sans+Pro" type="text/css">
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700|Source+Code+Pro" type="text/css">
    <!-- styling -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap-theme.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="../assets/css/style.css">
    <!-- scripts -->
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
    <script src="../assets/js/script.js"></script>
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body>

<div id="doc">
  <nav id="hd" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a href="" class="navbar-brand">
          <img src="../assets/img/logo.svg" />JS<small>Version: 0.3.0</small>
        </a>
      </div>
      <div id="navbar" class="navbar-collapse collapse">
        <ul id="api-list" class="nav navbar-nav navbar-right">
  <li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Classes <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      
        <li><a href="../classes/Skylink.html">Skylink</a></li>
      
        <li><a href="../classes/SkylinkCC.html">SkylinkCC</a></li>
      
    </ul>
  </li>
  <!--<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Modules <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      <li><a href="#api-modules">View all Modules</a></li>
      
    </ul>
  </li>-->
  <li><a href="https://temasys.github.io">Getting Started</a></li>
</ul>
<!--<form id="api-tabview" class="navbar-form navbar-right" role="form">
  <div id="api-tabview-filter" class="form-group">
    <input type="search" id="api-filter" placeholder="Type to filter APIs">
  </div>
</form>-->
      </div><!--/.navbar-collapse -->
    </div>
  </nav>
  <div id="bd" class="yui3-g">

      <div class="yui3-u-1-4">

      </div>
      <div class="yui3-u-3-4">
           options
          <div class="apidocs">
              <div id="docs-main">
                  <div class="content">
                      <h1 class="file-heading">File: source/skylinkcc.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * @class SkylinkCC
 * @extends Skylink
 * @requires Skylink
 */
(function() {
/**
 * SkylinkCC is a implementation from Skylink to create a control center like
 * use-case. Things to take note are:
 * - Skyway.init() is required to be called before
 *   {{#crossLink &quot;SkylinkCC/connect:method&quot;}}connect(){{/crossLink}}
 * - To disconnect users from the lobby or the room, call Skyway.leaveRoom()
 *   instead.
 * - If there&#x27;s no lobbyRoom specified, &#x27;MAIN&#x27; is the main lobby
 * - Check out the rest of the other functionalities in the
 *   [Skyway documentation](http://cdn.temasys.com.sg/skyway/skywayjs
 *   /0.3.1/doc/classes/Skyway.html).
 * @class SkylinkCC
 * @constructor
 * @example
 *   // Getting started on how to use Skyway
 *   // Note that init() is still required to be called as init() is to fetch
 *   // server connection information.
 *   var SkylinkDemo = new SkylinkCC();
 *   SkylinkDemo.init({
 *     defaultRoom: &#x27;default&#x27;,
 *     apiKey: &#x27;apiKey&#x27;
 *   });
 * @since 0.1.0
 */
function SkylinkCC() {
  if (!Skylink) {
    log.error(&#x27;Skylink is not loaded. Please load Skylink first before SkylinkCC.&#x27;);
  }
}
// Initialize SkylinkCC as Skyway and start
SkylinkCC.prototype = new Skylink();
this.SkylinkCC = SkylinkCC;

/**
 * Version of SkylinkCC
 * @attribute VERSION
 * @type String
 * @readOnly
 * @for SkylinkCC
 * @since 0.1.0
 */
SkylinkCC.prototype.VERSION = &#x27;@@version&#x27;;

/**
 * State if User is in lobby room or not
 * @attribute _in_lobby
 * @type Boolean
 * @private
 * @required
 * @for SkylinkCC
 * @since 0.1.0
 */
SkylinkCC.prototype._in_lobby = false;

/**
 * The default lobby room.
 * @attribute _defaultLobbyRoom
 * @type String
 * @private
 * @required
 * @for SkylinkCC
 * @since 0.1.0
 */
SkylinkCC.prototype._defaultLobbyRoom = &#x27;MAIN&#x27;;

/**
 * The lobby room
 * @attribute _lobbyRoom
 * @type String
 * @default _defaultLobbyRoom
 * @private
 * @required
 * @for SkylinkCC
 * @since 0.1.0
 */
SkylinkCC.prototype._lobbyRoom = false;

/**
 * The ready state of the peer&#x27;s call if they are ready to join the room.
 * @attribute CALL_READY_STATE
 * @type JSON
 * @param {Integer} LOBBY         Step 1. Peer is in lobby
 * @param {Integer} REQUEST_CALL  Step 2. Agent requests to start the call
 * @param {Integer} ACCEPTED_CALL Step 3a. Client accepted the call
 * @param {Integer} REJECTED_CALL Step 3b. Client rejected the call.
 * @param {Integer} START_CALL    Step 4. Agent and Client is ready to start the call.
 * @param {Intger}
 * @readOnly
 * @for SkylinkCC
 * @since 0.1.0
 */
SkylinkCC.prototype.CALL_READY_STATE = {
  LOBBY: 1,
  REQUEST_CALL: 2,
  ACCEPTED_CALL: 3,
  START_CALL: 4,
  REJECTED_CALL: -1
};

/**
 * User object
 * @attribute _user
 * @type JSON
 * @param {String} id User Session ID
 * @param {Object} peer PeerConnection object
 * @param {String} sid User Secret Session ID
 * @param {String} apiOwner Owner of the room
 * @param {Array} streams Array of User&#x27;s MediaStream
 * @param {String} timestamp User&#x27;s timestamp
 * @param {String} token User access token
 * @param {JSON} info Optional. User information
 * @param {JSON} info.settings Peer stream settings
 * @param {Boolean|JSON} info.settings.audio
 * @param {Boolean} info.settings.audio.stereo
 * @param {Boolean|JSON} info.settings.video
 * @param {Bolean|JSON} info.settings.video.resolution [Rel: SkylinkCC.VIDEO_RESOLUTION]
 * @param {Integer} info.settings.video.resolution.width
 * @param {Integer} info.settings.video.resolution.height
 * @param {Integer} info.settings.video.frameRate
 * @param {JSON} info.mediaStatus Peer stream status.
 * @param {Boolean} info.mediaStatus.audioMuted If Peer&#x27;s Audio stream is muted.
 * @param {Boolean} info.mediaStatus.videoMuted If Peer&#x27;s Video stream is muted.
 * @param {String|JSON} info.userData Peer custom data
 * @param {JSON} info.call Peer call status object.
 * @param {Integer} info.call.status The current ready state of the user&#x27;s call.
 *   [Rel: SkylinkCC.CALL_READY_STATE]
 * @param {String} info.call.targetPeerId PeerId the call to direct to.
 * @param {String} info.call.peerType Peer type [Rel: SkylinkCC.PEER_TYPE]
 * @param {String} info.call.targetRoom The targeted Room to join. Default is
 *   info.call.targetPeerId if not specified.
 * @required
 * @private
 * @for SkylinkCC
 * @since 0.1.0
 */
SkylinkCC.prototype._user = null;

/**
 * Object to store temporary information
 * @attribute _temp
 * @type Array
 * @private
 * @for SkylinkCC
 * @since 0.1.0
 */
SkylinkCC.prototype._temp = [];

/**
 * If peer is agent or customer. Types are:
 * @attribute PEER_TYPE
 * @type JSON
 * @param {String} CUSTOMER  User is customer
 * @param {String} AGENT     User is agent
 * @readOnly
 * @for SkylinkCC
 * @since 0.1.0
 */
SkylinkCC.prototype.PEER_TYPE = {
  CLIENT: &#x27;client&#x27;,
  AGENT: &#x27;agent&#x27;
};

/**
 * The log key
 * @type String
 * @global true
 * @readOnly
 * @for SkylinkCC
 * @since 0.3.0
 */
var _LOG_KEY = &#x27;SkylinkJS&#x27;;

/**
 * The log level of Skylink
 * @attribute _logLevel
 * @type String
 * @default Skylink.LOG_LEVEL.DEBUG
 * @required
 * @global true
 * @private
 * @for SkylinkCC
 * @since 0.3.0
 */
var _logLevel = 4;

/**
 * The current state if debugging mode is enabled.
 * @attribute _enableDebugMode
 * @type Boolean
 * @default false
 * @private
 * @required
 * @global true
 * @for SkylinkCC
 * @since 0.3.0
 */
var _enableDebugMode = false;

/**
 * Logs all the console information.
 * @method _logFn
 * @param {String} logLevel The log level.
 * @param {Array|String} message The console message.
 * @param {String} message.0 The targetPeerId the message is targeted to.
 * @param {String} message.1 The interface the message is targeted to.
 * @param {String|Array} message.2 The events the message is targeted to.
 * @param {String} message.3: The log message.
 * @param {Object|String} [debugObject] The console parameter string or object.
 * @private
 * @required
 * @global true
 * @for SkylinkCC
 * @since 0.3.0
 */
var _logFn = function(logLevel, message, debugObject) {
  var levels = [&#x27;error&#x27;, &#x27;warn&#x27;, &#x27;info&#x27;, &#x27;log&#x27;, &#x27;debug&#x27;];
  var outputLog = _LOG_KEY;

  if (_logLevel &gt;= logLevel) {
    if (typeof message === &#x27;object&#x27;) {
      outputLog += (message[0]) ? &#x27; [&#x27; + message[0] + &#x27;] -&#x27; : &#x27; -&#x27;;
      outputLog += (message[1]) ? &#x27; &lt;&lt;&#x27; + message[1] + &#x27;&gt;&gt;&#x27; : &#x27;&#x27;;
      if (message[2]) {
        outputLog += &#x27; &#x27;;
        if (typeof message[2] === &#x27;object&#x27;) {
          for (var i = 0; i &lt; message[2].length; i++) {
            outputLog += &#x27;(&#x27; + message[2][i] + &#x27;)&#x27;;
          }
        } else {
          outputLog += &#x27;(&#x27; + message[2] + &#x27;)&#x27;;
        }
      }
      outputLog += &#x27; &#x27; + message[3];
    } else {
      outputLog += &#x27; - &#x27; + message;
    }
    // Fallback to log if failure
    var enableDebugOutputLog = &#x27;++ &#x27; + levels[logLevel].toUpperCase() + &#x27; ++  &#x27; + outputLog;

    logLevel = (typeof console[levels[logLevel]] === &#x27;undefined&#x27;) ? 3 : logLevel;

    if (_enableDebugMode) {
      var logConsole = (typeof console.trace === &#x27;undefined&#x27;) ? logLevel[3] : &#x27;trace&#x27;;
      if (typeof debugObject !== &#x27;undefined&#x27;) {
        console[logConsole](enableDebugOutputLog, debugObject);
      } else {
        console[logConsole](enableDebugOutputLog);
      }
    } else {
      if (typeof debugObject !== &#x27;undefined&#x27;) {
        console[levels[logLevel]](outputLog, debugObject);
      } else {
        console[levels[logLevel]](outputLog);
      }
    }
  }
};

/**
 * Logs all the console information.
 * @attribute log
 * @type JSON
 * @param {Function} debug For debug mode.
 * @param {Function} log For log mode.
 * @param {Function} info For info mode.
 * @param {Function} warn For warn mode.
 * @param {Function} serror For error mode.
 * @private
 * @required
 * @global true
 * @for SkylinkCC
 * @since 0.3.0
 */
/**
 * Outputs a debug log in the console.
 * @method log.debug
 * @param {Array|String} message or the message
 * @param {String} message.0 The targetPeerId the log is targetted to
 * @param {String} message.1 he interface the log is targetted to
 * @param {String|Array} message.2 The related names, keys or events to the log
 * @param {String} message.3 The log message.
 * @param {String|Object} [object] The log object.
 * @example
 *   // Logging for message
 *   log.debug(&#x27;This is my message&#x27;, object);
 * @private
 * @required
 * @global true
 * @for SkylinkCC
 * @since 0.3.0
 */
/**
 * Outputs a normal log in the console.
 * @method log.log
 * @param {Array|String} message or the message
 * @param {String} message.0 The targetPeerId the log is targetted to
 * @param {String} message.1 he interface the log is targetted to
 * @param {String|Array} message.2 The related names, keys or events to the log
 * @param {String} message.3 The log message.
 * @param {String|Object} [object] The log object.
 * @example
 *   // Logging for message
 *   log.log(&#x27;This is my message&#x27;, object);
 * @private
 * @required
 * @global true
 * @for SkylinkCC
 * @since 0.3.0
 */
/**
 * Outputs an info log in the console.
 * @method log.info
 * @param {Array|String} message or the message
 * @param {String} message.0 The targetPeerId the log is targetted to
 * @param {String} message.1 he interface the log is targetted to
 * @param {String|Array} message.2 The related names, keys or events to the log
 * @param {String} message.3 The log message.
 * @param {String|Object} [object] The log object.
 * @example
 *   // Logging for message
 *   log.debug(&#x27;This is my message&#x27;, object);
 * @private
 * @required
 * @global true
 * @for SkylinkCC
 * @since 0.3.0
 */
/**
 * Outputs a warning log in the console.
 * @method log.warn
 * @param {Array|String} message or the message
 * @param {String} message.0 The targetPeerId the log is targetted to
 * @param {String} message.1 he interface the log is targetted to
 * @param {String|Array} message.2 The related names, keys or events to the log
 * @param {String} message.3 The log message.
 * @param {String|Object} [object] The log object.
 * @example
 *   // Logging for message
 *   log.debug(&#x27;Here\&#x27;s a warning. Please do xxxxx to resolve this issue&#x27;, object);
 * @private
 * @required
 * @for SkylinkCC
 * @since 0.3.0
 */
/**
 * Outputs an error log in the console.
 * @method log.error
 * @param {Array|String} message or the message
 * @param {String} message.0 The targetPeerId the log is targetted to
 * @param {String} message.1 he interface the log is targetted to
 * @param {String|Array} message.2 The related names, keys or events to the log
 * @param {String} message.3 The log message.
 * @param {String|Object} [object] The log object.
 *   // Logging for external information
 *   log.error(&#x27;There has been an error&#x27;, object);
 * @private
 * @required
 * @global true
 * @for SkylinkCC
 * @since 0.3.0
 */
var log = {
  debug: function (message, object) {
    _logFn(4, message, object);
  },
  log: function (message, object) {
    _logFn(3, message, object);
  },
  info: function (message, object) {
    _logFn(2, message, object);
  },
  warn: function (message, object) {
    _logFn(1, message, object);
  },
  error: function (message, object) {
    _logFn(0, message, object);
  }
};

/**
 * Connect user to the main lobby.
 * - Please call this only after calling Skyway.init().
 * - To disconect from the lobby, please call Skyway.leaveRoom().
 * @method connect
 * @param {String} lobbyRoom The lobby all peers connect to before the call starts.
 * @param {JSON|String} userData The user custom data.
 * @param {String} peerType Deprecated. The peer type [Rel: SkylinkCC.PEER_TYPE].
 *   This would be removed from the specs once agent and client is identified
 *   from the request url.
 * @example
 *   SkylinkDemo.connect(&#x27;main_lobby&#x27;, {
 *     &#x27;displayName&#x27;: &#x27;Agent Bob&#x27;,
 *     &#x27;timeStamp&#x27;: (new Date()).toISOString,
 *     &#x27;status&#x27;: CALL_CENTER.EVENT.STARTING,
 *     &#x27;UUID&#x27;: &#x27;XXX-XXX-XXXX&#x27;
 *   }, SkylinkDemo.PEER_TYPE.AGENT);
 * @trigger peerJoined
 * @for SkylinkCC
 * @required
 * @for SkylinkCC
 * @since 0.1.0
 */
SkylinkCC.prototype.connect = function (lobbyRoom, userData, peerType) {
  var self = this;
  var checkReadyState = setInterval(function() {
    if (self._readyState === self.READY_STATE_CHANGE.COMPLETED &amp;&amp;
      self._user) {
      clearInterval(checkReadyState);
      self._temp.userCall = {
        status: self.CALL_READY_STATE.LOBBY,
        peerType: peerType || self.PEER_TYPE.CLIENT
      };
      self._lobbyRoom = lobbyRoom || self._defaultLobbyRoom;
      self.joinRoom(self._lobbyRoom, {
        userData: userData,
        audio: false,
        video: false
      });
    }
  });
};

/**
 * We just joined a room! Let&#x27;s send a nice message to all to let them know I&#x27;m in.
 * @method _inRoomHandler
 * @param {JSON} message
 * @param {String} message.rid RoomId of the connected room.
 * @param {String} message.sid PeerId of self.
 * @param {String} message.mid PeerId of the peer that is
 * @param {JSON} message.pc_config The peerconnection configuration
 *   sending the joinRoom message.
 * @param {String} message.type The type of message received.
 * @trigger peerJoined
 * @private
 * @overwritten_from SkylinkJS
 * @since 0.3.0
 */
SkylinkCC.prototype._inRoomHandler = function(message) {
  var self = this;
  log.log([&#x27;Server&#x27;, null, message.type, &#x27;User is now in the room and &#x27; +
    &#x27;functionalities are now available. Config received:&#x27;], message.pc_config);
  self._room.connection.peerConfig = self._setIceServers(message.pc_config);
  self._inRoom = true;
  self._user.sid = message.sid;
  // NOTE ALEX: should we wait for local streams?
  // or just go with what we have (if no stream, then one way?)
  // do we hardcode the logic here, or give the flexibility?
  // It would be better to separate, do we could choose with whom
  // we want to communicate, instead of connecting automatically to all.
  // Re-set the information
  if (self._user.info.call) {
    if (self._user.info.call.status === self.CALL_READY_STATE.LOBBY) {
      self._in_lobby = true;
    }
  } else {
    if (self._temp.userCall) {
      self._user.info.call = self._temp.userCall;
      delete self._temp.userCall;
    }
    if (self._temp.userData) {
      self._user.info.userData = self._temp.userData;
      delete self._temp.userData;
    }
  }
  self._trigger(&#x27;peerJoined&#x27;, self._user.sid, self._user.info, true);

  // NOTE ALEX: should we wait for local streams?
  // or just go with what we have (if no stream, then one way?)
  // do we hardcode the logic here, or give the flexibility?
  // It would be better to separate, do we could choose with whom
  // we want to communicate, instead of connecting automatically to all.
  self._sendChannelMessage({
    type: self._SIG_MESSAGE_TYPE.ENTER,
    mid: self._user.sid,
    rid: self._room.id,
    agent: window.webrtcDetectedBrowser,
    version: window.webrtcDetectedVersion,
    userInfo: self._user.info
  });
  log.log(&#x27;Sending enter&#x27;);
  self._trigger(&#x27;handshakeProgress&#x27;, self.HANDSHAKE_PROGRESS.ENTER, self._user.sid);
};

/**
 * Throw an event with the received private message
 * @method _privateMessageHandler
 * @param {JSON} message The message object.
 * @param {JSON|String} message.data The data broadcasted.
 * @param {String} message.mid PeerId of the peer that sent
 *   the call status message.
 * @param {String} message.cid CredentialId for the room.
 * @param {String} message.rid RoomId of the room peer is connected to.
 * @param {String} message.callStatus Is the message a callStatus event.
 * @param {String} message.type The type of the message.
 * @trigger privateMessage, peerCallRequest
 * @private
 * @overwritten_from SkylinkJS
 * @since 0.3.0
 */
SkylinkCC.prototype._privateMessageHandler = function(message) {
  var targetMid = message.mid;
  if (message.callStatus) {
    this._callStatusHandler(targetMid, message, true);
  } else {
    log.log([targetMid, null, message.type,
      &#x27;Received private message from peer:&#x27;], message.data);
    this._trigger(&#x27;incomingMessage&#x27;, {
      content: message.data,
      isPrivate: true,
      targetPeerId: message.target, // is not null if there&#x27;s user
      isDataChannel: false,
      senderPeerId: targetMid
    }, targetMid, this._peerInformations[targetMid], false);
  }
};

/**
 * Throw an event with the received private message
 * @method _publicMessageHandler
 * @param {JSON} message The message object.
 * @param {JSON|String} message.data The data broadcasted.
 * @param {String} message.mid PeerId of the peer that sent
 *   the call status message.
 * @param {String} message.cid CredentialId for the room.
 * @param {String} message.rid RoomId of the room peer is connected to.
 * @param {String} message.callStatus Is the message a callStatus event.
 * @param {String} message.type The type of the message.
 * @trigger publicMessage, peerCallRequest
 * @private
 * @overwritten_from SkylinkJS
 * @since 0.1.0
 */
SkylinkCC.prototype._publicMessageHandler = function(message) {
  var targetMid = message.mid;
  if (message.callStatus) {
    this._callStatusHandler(targetMid, message, false);
  } else {
    log.log([targetMid, null, message.type,
      &#x27;Received public message from peer:&#x27;], message.data);
    this._trigger(&#x27;incomingMessage&#x27;, {
      content: message.data,
      isPrivate: false,
      targetPeerId: null, // is not null if there&#x27;s user
      isDataChannel: false,
      senderPeerId: targetMid
    }, targetMid, this._peerInformations[targetMid], false);
  }
};

/**
 * Handles all call status event changes
 * @method _callStatusHandler
 * @param {String} targetMid PeerId of the peer that sent
 *   the call status message.
 * @param {JSON} message The message object.
 * @param {JSON|String} message.data The data broadcasted.
 * @param {String} message.mid PeerId of the peer that sent
 *   the call status message.
 * @param {String} message.cid CredentialId for the room.
 * @param {String} message.rid RoomId of the room peer is connected to.
 * @param {String} message.callStatus Is the message a callStatus event.
 * @param {String} message.type The type of the message.
 * @param {Boolean} isPrivate Is the message a targeted message or not.
 * @trigger peerCallRequest
 * @private
 * @since 0.1.0
 */
SkylinkCC.prototype._callStatusHandler = function(targetMid, message, isPrivate) {
  var call = message.data;
  var checkPrivate = (call.status &gt;= this.CALL_READY_STATE.REQUEST_CALL) ?
    (call.targetPeerId === this._user.sid) : true;

  if (isPrivate &amp;&amp; checkPrivate) {
    this._peerInformations[targetMid].call = call;
    this._user.info.call.status = call.status;
    this._trigger(&#x27;peerCallRequest&#x27;, targetMid,
      this._peerInformations[targetMid], false);
  } else if (!isPrivate) {
    this._peerInformations[message.sender].call = call;
    // Customer cannot see agent information
    if (call.peerType === this.PEER_TYPE.AGENT) {
      this._trigger(&#x27;peerCallRequest&#x27;, targetMid,
        this._peerInformations[targetMid], false);
    }
  } else {
    log.error([message.mid, &#x27;CallStatus&#x27;, call.status,
      &#x27;Dropped request because targetPeerId does not match&#x27;], call);
  }
};

/**
 * Trigger a event after updating userData.
 * @method startPeerEvent
 * @param {JSON|String} userData The peer&#x27;s updated user data to send over.
 * @param {JSON} event The event object. Event triggered will only be
 *   directed to self.
 * @param {String} event.name The event to be trigged.
 * @param {JSON|String|Array} event.params The event params.
 * @example
 *   var userData = SkylinkDemo.getUserData().userData;
 *   userData.status = &#x27;newEvent&#x27;;
 *   SkylinkDemo.startPeerEvent(userData, {
 *     name: &#x27;newEvent&#x27;,
 *     params: {
 *       &#x27;startAdvert&#x27;: true,
 *       &#x27;UUID&#x27;: &#x27;XXXX-XXX-XXX&#x27;
 *     }
 *   });
 *   SkylinkDemo.on(&#x27;newEvent&#x27;, function (params) {
 *     // ....
 *   });
 * @trigger [customEvent]
 * @since 0.1.0
 */
SkylinkCC.prototype.startPeerEvent = function (userData, event) {
  var self = this;
  for (var e in this._EVENTS) {
    if (this._EVENTS[e] === event.name) {
      log.error(&#x27;You cannot call a Skyway event.&#x27;);
      return;
    }
  }
  if (event.name) {
    setTimeout(function () {
      self.setUserData(userData);
      self._trigger(event.name, event.params);
    }, 200);
  } else {
    log.error(&#x27;No event name is provided&#x27;);
  }
};

/**
 * Handles all call states.
 * @method _handleCall
 * @param {String} peerId PeerId of the peer to send request to.
 * @param {JSON} options Peer call status object.
 * @param {JSON} options.status Peer call status [Rel: SkylinkCC.CALL_STATUS]
 * @param {Boolean} options.peerType Peer user type [Rel: SkylinkCC.PEER_TYPE]
 * @param {String} options.targetPeerId PeerId of the peer the call request
 *   is directed to.
 * @param {String} options.targetRoom Room that the peer requests to join.
 * @param {Function} callback Callback function once call message is sent.
 * @trigger peerCallRequest
 * @private
 * @since 0.1.0
 */
SkylinkCC.prototype._handleCall = function (peerId, options, callback) {
  if (!this._user) {
    log.error(&#x27;&quot;_user&quot; object is not loaded yet. Check readyState.&#x27;);
    return;
  } else if (!this._user.info) {
    log.error(&#x27;&quot;_user.info&quot; object is not loaded yet. Check readyState.&#x27;);
    return;
  } else if (!this._user.info.call) {
    log.error(&#x27;&quot;_user.info.call&quot; object is not loaded yet. Check readyState.&#x27;);
    return;
  } else if (this._user.info.call.peerType !== options.peerType) {
    log.error(&#x27;Peer type is not &#x27; + options.peerType + &#x27;. Peer type is: &quot;&#x27; +
      this._user.info.call.peerType);
    return;
  }
  this._user.info.call.status = options.status || this._user.info.call.status;
  this._user.info.call.targetPeerId = options.targetPeerId ||
    this._user.info.call.targetPeerId;
  this._user.info.call.targetRoom = options.targetRoom ||
    this._user.info.call.targetRoom || null;
  this._sendChannelMessage({
    cid: this._key,
    mid: this._user.sid,
    rid: this._room.id,
    data: this._user.info.call,
    target: peerId,
    type: this._SIG_MESSAGE_TYPE.PRIVATE_MESSAGE,
    callStatus: true
  });
  this._trigger(&#x27;peerCallRequest&#x27;, this._user.sid, this._user.info, true);
  if (callback) {
    callback();
  }
};

/**
 * Step 1: Agent requests to start the call to client
 * @method agentRequestCall
 * @param {String} clientPeerId Client peerId to start call to.
 * @param {String} room Room to ask client to join in
 * @example
 *   // Example 1: Request call
 *   SkylinkDemo.agentRequestCall(peerId);
 *
 *   // Example 2: Request call with a specific room
 *   SkylinkDemo.agentRequestCall(peerId, room);
 * @trigger peerCallRequest
 * @since 0.1.0
 */
SkylinkCC.prototype.agentRequestCall = function (clientPeerId, room) {
  this._handleCall(clientPeerId, {
    status: this.CALL_READY_STATE.REQUEST_CALL,
    targetPeerId: clientPeerId,
    targetRoom: room || clientPeerId,
    peerType: this.PEER_TYPE.AGENT
  });
};

/**
 * Step 2: Client to accept or reject the call.
 * @method acceptRequestCall
 * @param {String} agentPeerId PeerId of the agent.
 * @param {Boolean} accept If client accepts agent request or not.
 * @example
 *   SkylinkDemo.on(&#x27;peerCallRequest&#x27;, function (peerId, peerInfo, isSelf)) {
 *     if (!isSelf) {
 *       if (peerInfo.call.status === SkylinkDemo.CALL_STATUS.REQUEST_CALL) {
 *         var result = confirm(&#x27;Do you want to accept the call?&#x27;);
 *         SkylinkDemo.acceptRequestCall(peerId, result);
 *       }
 *     }
 *   });
 * @trigger peerCallRequest
 * @since 0.1.0
 */
SkylinkCC.prototype.acceptRequestCall = function (agentPeerId, accept) {
  this._handleCall(agentPeerId, {
    status: ((accept) ? this.CALL_READY_STATE.ACCEPTED_CALL :
      this.CALL_READY_STATE.REJECTED_CALL),
    targetPeerId: agentPeerId,
    targetRoom: this._peerInformations[agentPeerId].call.targetRoom,
    peerType: this.PEER_TYPE.CLIENT
  });
};

/**
 * Step 3: Start the call. You may call method
 * - &quot;peerLeft&quot; would be triggered because user left the lobby room
 * - Call Skyway.joinRoom() to start the call.
 * Request a call for agent
 * @method startRequestCall
 * @param {String} room Room to ask client to join in
 * @param {Function} callback Callback after the room is ready to join
 * @return {JSON} User information object
 * @return {JSON} Peer information object
 * @example
 *   SkylinkDemo.on(&#x27;peerCallRequest&#x27;, function (peerId, peerInfo, isSelf)) {
 *     if (!isSelf) {
 *       if (peerInfo.call.status === SkylinkDemo.CALL_STATUS.START_CALL) {
 *         SkylinkDemo.startRequestCall(peerId, function (userInfo, peerInfo) {
 *           SkylinkDemo.joinRoom(peerInfo.call.targetRoom, {
 *             audio: true,
 *             video: true
 *           });
 *         });
 *       }
 *     }
 *   });
 * @trigger peerCallRequest, peerLeft
 * @since 0.2.0
 */
SkylinkCC.prototype.startRequestCall = function (targetPeerId, callback) {
  var self = this;
  var peerInfo;
  var doLeaveRoom = function () {
    var userInfo = self._user.info;
    self.leaveRoom();
    self._in_lobby = false;
    self._temp.userCall = userInfo.call;
    self._temp.userData = userInfo.userData;
    callback(userInfo, peerInfo);
  };
  if (self._user.info.call.peerType === self.PEER_TYPE.AGENT) {
    this._handleCall(targetPeerId, {
      status: self.CALL_READY_STATE.START_CALL,
      targetPeerId: targetPeerId,
      peerType: this.PEER_TYPE.AGENT
    }, function () {
      peerInfo = self._peerInformations[targetPeerId];
      setTimeout(function () {
        doLeaveRoom();
      }, 3500);
    });
  } else {
    peerInfo = self._peerInformations[targetPeerId];
    doLeaveRoom();
  }
};

/* Syntactically private variables and utility functions */
/**
 * Event fired when a peer call request has changed.
 * @event peerCallRequest
 * @param {String} peerId PeerId of the peer that has a call ready state changed.
 * @param {JSON} peerInfo Peer information of the peer
 * @param {JSON} peerInfo.settings Peer stream settings
 * @param {Boolean|JSON} peerInfo.settings.audio
 * @param {Boolean} peerInfo.settings.audio.stereo
 * @param {Boolean|JSON} peerInfo.settings.video
 * @param {JSON} peerInfo.settings.video.resolution [Rel: Skyway.VIDEO_RESOLUTION]
 * @param {Integer} peerInfo.settings.video.resolution.width
 * @param {Integer} peerInfo.settings.video.resolution.height
 * @param {Integer} peerInfo.settings.video.frameRate
 * @param {JSON} peerInfo.mediaStatus Peer stream status.
 * @param {Boolean} peerInfo.mediaStatus.audioMuted If Peer&#x27;s audio stream is muted.
 * @param {Boolean} peerInfo.mediaStatus.videoMuted If Peer&#x27;s video stream is muted.
 * @param {String|JSON} peerInfo.userData Peer custom data
 * @param {JSON} peerInfo.call Peer call status object.
 * @param {Integer} peerInfo.call.status Peer call status [Rel: SkylinkCC.CALL_STATUS]
 * @param {String} peerInfo.call.peerType Peer user type [Rel: SkylinkCC.PEER_TYPE]
 * @param {String} peerInfo.call.targetPeerId PeerId of the peer the call request
 *   is directed to.
 * @param {String} peerInfo.call.targetRoom Room that the peer requests to join.
 * @param {Boolean} isSelf Is the peer self.
 * @since 0.1.0
 */
SkylinkCC.prototype._EVENTS.peerCallRequest = [];

SkywayCC = SkylinkCC;
}).call(this);
    </pre>
</div>

                  </div>
              </div>
          </div>
      </div>
  </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
